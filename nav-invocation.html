<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigation Concept 5: Invocation Model</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #fafafa;
            color: #18181b;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            -webkit-font-smoothing: antialiased;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Input Container - Always Visible */
        .input-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            width: 100%;
            max-width: 800px;
            padding: 20px;
        }

        .input-container.section-active {
            top: auto;
            bottom: 60px;
            transform: translateX(-50%);
        }

        /* Large Typography Input */
        .input-wrapper {
            position: relative;
            display: inline-block;
        }

        .text-input {
            font-family: 'Inter', sans-serif;
            font-size: clamp(3rem, 12vw, 8rem);
            font-weight: 600;
            letter-spacing: -0.04em;
            color: #18181b;
            background: transparent;
            border: none;
            outline: none;
            text-align: center;
            width: 100%;
            min-width: 200px;
            caret-color: #18181b;
        }

        .text-input::placeholder {
            color: #d4d4d8;
        }

        .text-input:focus::placeholder {
            color: transparent;
        }

        /* Cursor blink */
        .cursor {
            display: inline-block;
            width: 4px;
            height: 1em;
            background: #18181b;
            margin-left: 4px;
            animation: blink 1s step-end infinite;
            vertical-align: text-bottom;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        /* Preview hint */
        .preview-hint {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 20px;
            font-size: 0.875rem;
            color: #a1a1aa;
            letter-spacing: 0.05em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .preview-hint.visible {
            opacity: 1;
        }

        .preview-hint .match {
            color: #18181b;
            font-weight: 500;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #a1a1aa;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            transition: opacity 0.3s ease;
        }

        .instructions.hidden {
            opacity: 0;
        }

        /* Section Preview (fades in as you type) */
        .section-preview {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.4s ease;
        }

        .section-preview.visible {
            opacity: 0.15;
        }

        .section-preview .preview-text {
            font-size: clamp(6rem, 20vw, 15rem);
            font-weight: 600;
            letter-spacing: -0.05em;
            color: #18181b;
            text-transform: capitalize;
        }

        /* Active Section */
        .section-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        .section-container.active {
            opacity: 1;
            pointer-events: auto;
        }

        .section-content {
            max-width: 700px;
            padding: 40px;
            text-align: center;
        }

        .section-content h2 {
            font-size: clamp(2.5rem, 8vw, 5rem);
            font-weight: 600;
            letter-spacing: -0.03em;
            margin-bottom: 1.5rem;
        }

        .section-content p {
            font-size: 1rem;
            color: #71717a;
            line-height: 1.8;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Section list hint */
        .section-list {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 150;
        }

        .section-list span {
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #d4d4d8;
            transition: color 0.3s ease;
            cursor: pointer;
        }

        .section-list span:hover {
            color: #71717a;
        }

        .section-list span.matched {
            color: #18181b;
        }

        .section-list span.active {
            color: #18181b;
            font-weight: 500;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .text-input {
                font-size: clamp(2rem, 10vw, 4rem);
            }

            .section-list {
                gap: 15px;
                flex-wrap: wrap;
                justify-content: center;
                padding: 0 20px;
            }

            .input-container.section-active {
                bottom: 40px;
            }
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>

    <!-- Section List Hints -->
    <div class="section-list" id="section-list">
        <span data-section="projects">Projects</span>
        <span data-section="contact">Contact</span>
        <span data-section="about">About</span>
        <span data-section="skills">Skills</span>
    </div>

    <!-- Input Container -->
    <div class="input-container" id="input-container">
        <div class="input-wrapper">
            <input
                type="text"
                class="text-input"
                id="text-input"
                placeholder="Type..."
                autocomplete="off"
                autocapitalize="off"
                spellcheck="false"
            >
            <div class="preview-hint" id="preview-hint">
                Press Enter for <span class="match" id="match-name"></span>
            </div>
        </div>
    </div>

    <!-- Instructions -->
    <div class="instructions" id="instructions">
        Type a section name to navigate
    </div>

    <!-- Section Preview (background) -->
    <div class="section-preview" id="section-preview">
        <span class="preview-text" id="preview-text"></span>
    </div>

    <!-- Section Containers -->
    <div class="section-container" id="section-projects">
        <div class="section-content">
            <h2>Projects</h2>
            <p>A curated selection of work spanning interface design, creative development, and interactive experiences.</p>
        </div>
    </div>

    <div class="section-container" id="section-contact">
        <div class="section-content">
            <h2>Contact</h2>
            <p>Open to collaboration on ambitious projects. Let's create something meaningful together.</p>
        </div>
    </div>

    <div class="section-container" id="section-about">
        <div class="section-content">
            <h2>About</h2>
            <p>Designer and developer focused on crafting interfaces that feel inevitable. Based in the intersection of form and function.</p>
        </div>
    </div>

    <div class="section-container" id="section-skills">
        <div class="section-content">
            <h2>Skills</h2>
            <p>Frontend architecture, motion design, creative coding, and the delicate art of making complex things feel simple.</p>
        </div>
    </div>

    <script>
        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');

        const CONFIG = {
            particleCount: 500,
            particleSize: 1,
            baseColor: '39, 39, 42',
            mouseRadius: 80
        };

        let particles = [];
        let textParticles = [];
        let width, height;
        let mouse = { x: -9999, y: -9999 };

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * CONFIG.particleSize + 0.3;
                this.alpha = Math.random() * 0.3 + 0.1;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderSpeed = 0.08 + Math.random() * 0.12;
            }

            update() {
                this.wanderAngle += (Math.random() - 0.5) * 0.05;
                this.x += Math.cos(this.wanderAngle) * this.wanderSpeed;
                this.y += Math.sin(this.wanderAngle) * this.wanderSpeed;

                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < CONFIG.mouseRadius) {
                    const force = (CONFIG.mouseRadius - dist) / CONFIG.mouseRadius;
                    this.x -= (dx / dist) * force * 1.2;
                    this.y -= (dy / dist) * force * 1.2;
                }

                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }

            draw() {
                ctx.fillStyle = `rgba(${CONFIG.baseColor}, ${this.alpha})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        function initParticles() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];

            for (let i = 0; i < CONFIG.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, width, height);

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw text particles (for transitions)
            textParticles = textParticles.filter(p => p.alpha > 0);
            textParticles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        // ============================================
        // TEXT-TO-PARTICLE EXPLOSION
        // ============================================
        function createTextExplosion(text, x, y, fontSize) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;

            tempCtx.font = `600 ${fontSize}px Inter`;
            tempCtx.fillStyle = 'white';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(text, x, y);

            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const gap = 3;

            for (let py = 0; py < height; py += gap) {
                for (let px = 0; px < width; px += gap) {
                    const index = (py * width + px) * 4 + 3;
                    if (data[index] > 128) {
                        const particle = {
                            x: px,
                            y: py,
                            originX: px,
                            originY: py,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15 - 3,
                            size: Math.random() * 2 + 1,
                            alpha: 1,
                            decay: 0.015 + Math.random() * 0.01,

                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.vx *= 0.96;
                                this.vy *= 0.96;
                                this.vy += 0.1;
                                this.alpha -= this.decay;
                            },

                            draw() {
                                ctx.fillStyle = `rgba(${CONFIG.baseColor}, ${this.alpha})`;
                                ctx.fillRect(this.x, this.y, this.size, this.size);
                            }
                        };

                        textParticles.push(particle);
                    }
                }
            }
        }

        function createTextConverge(text, x, y, fontSize, callback) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;

            tempCtx.font = `600 ${fontSize}px Inter`;
            tempCtx.fillStyle = 'white';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(text, x, y);

            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const gap = 4;
            let particleCount = 0;
            let completedCount = 0;

            for (let py = 0; py < height; py += gap) {
                for (let px = 0; px < width; px += gap) {
                    const index = (py * width + px) * 4 + 3;
                    if (data[index] > 128) {
                        particleCount++;
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 100 + Math.random() * 200;

                        const particle = {
                            x: px + Math.cos(angle) * distance,
                            y: py + Math.sin(angle) * distance,
                            targetX: px,
                            targetY: py,
                            size: Math.random() * 2 + 1,
                            alpha: 0,
                            speed: 0.03 + Math.random() * 0.02,
                            arrived: false,

                            update() {
                                if (this.arrived) {
                                    this.alpha -= 0.05;
                                    return;
                                }

                                const dx = this.targetX - this.x;
                                const dy = this.targetY - this.y;
                                const dist = Math.hypot(dx, dy);

                                this.x += dx * this.speed;
                                this.y += dy * this.speed;
                                this.alpha = Math.min(this.alpha + 0.05, 1);

                                if (dist < 3 && !this.arrived) {
                                    this.arrived = true;
                                    completedCount++;
                                    if (completedCount >= particleCount * 0.8 && callback) {
                                        callback();
                                        callback = null;
                                    }
                                }
                            },

                            draw() {
                                if (this.alpha <= 0) return;
                                ctx.fillStyle = `rgba(${CONFIG.baseColor}, ${this.alpha})`;
                                ctx.fillRect(this.x, this.y, this.size, this.size);
                            }
                        };

                        textParticles.push(particle);
                    }
                }
            }
        }

        // ============================================
        // INVOCATION NAVIGATION
        // ============================================
        const sections = ['projects', 'contact', 'about', 'skills'];
        const textInput = document.getElementById('text-input');
        const inputContainer = document.getElementById('input-container');
        const instructions = document.getElementById('instructions');
        const previewHint = document.getElementById('preview-hint');
        const matchName = document.getElementById('match-name');
        const sectionPreview = document.getElementById('section-preview');
        const previewText = document.getElementById('preview-text');
        const sectionListItems = document.querySelectorAll('.section-list span');

        let currentMatch = null;
        let activeSection = null;

        function findMatch(input) {
            if (!input) return null;
            const lower = input.toLowerCase();
            return sections.find(s => s.startsWith(lower));
        }

        function updatePreview(input) {
            const match = findMatch(input);
            currentMatch = match;

            // Update section list highlighting
            sectionListItems.forEach(item => {
                item.classList.remove('matched', 'active');
                if (match && item.dataset.section === match) {
                    item.classList.add('matched');
                }
                if (activeSection && item.dataset.section === activeSection) {
                    item.classList.add('active');
                }
            });

            if (match && input.length > 0) {
                // Show hint
                matchName.textContent = match.charAt(0).toUpperCase() + match.slice(1);
                previewHint.classList.add('visible');

                // Show background preview
                previewText.textContent = match;
                sectionPreview.classList.add('visible');

                // Fade preview based on completion
                const completion = input.length / match.length;
                sectionPreview.style.opacity = Math.min(completion * 0.3, 0.2);
            } else {
                previewHint.classList.remove('visible');
                sectionPreview.classList.remove('visible');
            }
        }

        function navigateToSection(sectionName) {
            if (activeSection === sectionName) return;

            const section = document.getElementById(`section-${sectionName}`);
            if (!section) return;

            // Get input position for particle effect
            const inputRect = textInput.getBoundingClientRect();
            const centerX = inputRect.left + inputRect.width / 2;
            const centerY = inputRect.top + inputRect.height / 2;
            const fontSize = parseInt(window.getComputedStyle(textInput).fontSize);

            // Explode the typed text
            createTextExplosion(textInput.value, centerX, centerY, fontSize);

            // Clear input and hide preview
            textInput.value = '';
            sectionPreview.classList.remove('visible');
            previewHint.classList.remove('visible');

            // Move input to bottom
            inputContainer.classList.add('section-active');
            instructions.classList.add('hidden');

            // Close previous section if open
            if (activeSection) {
                const prevSection = document.getElementById(`section-${activeSection}`);
                gsap.to(prevSection, {
                    opacity: 0,
                    duration: 0.3,
                    onComplete: () => prevSection.classList.remove('active')
                });
            }

            // Show new section
            section.classList.add('active');
            gsap.fromTo(section,
                { opacity: 0 },
                { opacity: 1, duration: 0.5, delay: 0.2 }
            );

            const content = section.querySelector('.section-content');
            const h2 = content.querySelector('h2');
            const p = content.querySelector('p');

            gsap.fromTo([h2, p],
                { opacity: 0, y: 30 },
                {
                    opacity: 1,
                    y: 0,
                    duration: 0.6,
                    stagger: 0.15,
                    delay: 0.3,
                    ease: 'power3.out'
                }
            );

            activeSection = sectionName;
            updatePreview('');
        }

        function returnToNeutral() {
            if (!activeSection) return;

            const section = document.getElementById(`section-${activeSection}`);

            // Get section title for explosion
            const h2 = section.querySelector('h2');
            const rect = h2.getBoundingClientRect();
            const fontSize = parseInt(window.getComputedStyle(h2).fontSize);

            createTextExplosion(h2.textContent, rect.left + rect.width / 2, rect.top + rect.height / 2, fontSize);

            gsap.to(section, {
                opacity: 0,
                duration: 0.3,
                onComplete: () => section.classList.remove('active')
            });

            // Move input back to center
            inputContainer.classList.remove('section-active');
            instructions.classList.remove('hidden');

            activeSection = null;
            updatePreview('');
        }

        // Event Listeners
        textInput.addEventListener('input', (e) => {
            updatePreview(e.target.value);
        });

        textInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && currentMatch) {
                e.preventDefault();
                navigateToSection(currentMatch);
            }

            if (e.key === 'Escape') {
                if (activeSection) {
                    returnToNeutral();
                } else {
                    textInput.value = '';
                    updatePreview('');
                }
            }

            if (e.key === 'Backspace' && textInput.value === '' && activeSection) {
                returnToNeutral();
            }
        });

        // Click on section list items
        sectionListItems.forEach(item => {
            item.addEventListener('click', () => {
                const section = item.dataset.section;
                if (activeSection === section) {
                    returnToNeutral();
                } else {
                    textInput.value = section;
                    updatePreview(section);
                    navigateToSection(section);
                }
            });
        });

        // Keep input focused
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.section-list')) {
                textInput.focus();
            }
        });

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }
        });

        // Initialize
        window.addEventListener('resize', initParticles);
        initParticles();
        animate();

        // Focus input on load
        setTimeout(() => textInput.focus(), 100);
    </script>
</body>
</html>
