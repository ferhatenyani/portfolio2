<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigation Concept 1: Aperture Model</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        * {
            margin: 0; 
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #fafafa;
            color: #18181b;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            -webkit-font-smoothing: antialiased;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        #aperture-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 80;
        }

        /* Zone Areas (invisible hit areas) */
        .zone {
            position: fixed;
            z-index: 60;
            cursor: pointer;
        }

        .zone.top-left {
            top: 0;
            left: 0;
            width: 50%;
            height: 50%;
        }

        .zone.top-right {
            top: 0;
            right: 0;
            width: 50%;
            height: 50%;
        }

        .zone.bottom-left {
            bottom: 0;
            left: 0;
            width: 50%;
            height: 50%;
        }

        .zone.bottom-right {
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
        }

        /* Zone Labels */
        .zone-label {
            position: absolute;
            font-size: 0.65rem;
            font-weight: 500;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: #a1a1aa;
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .zone:hover .zone-label,
        .zone.active .zone-label {
            opacity: 1;
        }

        .zone.top-left .zone-label {
            top: 40px;
            left: 40px;
        }

        .zone.top-right .zone-label {
            top: 40px;
            right: 40px;
        }

        .zone.bottom-left .zone-label {
            bottom: 40px;
            left: 40px;
        }

        .zone.bottom-right .zone-label {
            bottom: 40px;
            right: 40px;
        }

        /* Section Containers (beneath aperture) */
        .section-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
        }

        .section-container.preview {
            opacity: 0.4;
            filter: brightness(0.7);
        }

        .section-container.active {
            opacity: 1;
            pointer-events: auto;
        }

        .section-content {
            max-width: 700px;
            padding: 40px;
            text-align: center;
        }

        .section-content h2 {
            font-size: clamp(2.5rem, 8vw, 5rem);
            font-weight: 600;
            letter-spacing: -0.03em;
            margin-bottom: 1.5rem;
        }

        .section-content p {
            font-size: 1rem;
            color: #71717a;
            line-height: 1.8;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Close Button */
        .close-btn {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #18181b;
            border: none;
            cursor: pointer;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .close-btn:hover {
            background: #3f3f46;
            transform: scale(1.05);
        }

        .close-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .close-btn::before,
        .close-btn::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 2px;
            background: #fafafa;
        }

        .close-btn::before {
            transform: rotate(45deg);
        }

        .close-btn::after {
            transform: rotate(-45deg);
        }

        /* Center instruction */
        .center-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #d4d4d8;
            z-index: 55;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .center-hint.hidden {
            opacity: 0;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .zone-label {
                font-size: 0.6rem;
            }

            .zone.top-left .zone-label,
            .zone.top-right .zone-label {
                top: 25px;
            }

            .zone.bottom-left .zone-label,
            .zone.bottom-right .zone-label {
                bottom: 25px;
            }

            .zone.top-left .zone-label,
            .zone.bottom-left .zone-label {
                left: 25px;
            }

            .zone.top-right .zone-label,
            .zone.bottom-right .zone-label {
                right: 25px;
            }

            .close-btn {
                top: 20px;
                right: 20px;
                width: 44px;
                height: 44px;
            }
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    <canvas id="aperture-canvas"></canvas>

    <!-- Center Hint -->
    <div class="center-hint" id="center-hint">Hover to preview Â· Click to enter</div>

    <!-- Zone Hit Areas -->
    <div class="zone top-left" data-section="projects">
        <span class="zone-label">Projects</span>
    </div>
    <div class="zone top-right" data-section="contact">
        <span class="zone-label">Contact</span>
    </div>
    <div class="zone bottom-left" data-section="about">
        <span class="zone-label">About</span>
    </div>
    <div class="zone bottom-right" data-section="skills">
        <span class="zone-label">Skills</span>
    </div>

    <!-- Close Button -->
    <button class="close-btn" id="close-btn" aria-label="Close section"></button>

    <!-- Section Containers -->
    <div class="section-container" id="section-projects">
        <div class="section-content">
            <h2>Projects</h2>
            <p>A curated selection of work spanning interface design, creative development, and interactive experiences.</p>
        </div>
    </div>

    <div class="section-container" id="section-contact">
        <div class="section-content">
            <h2>Contact</h2>
            <p>Open to collaboration on ambitious projects. Let's create something meaningful together.</p>
        </div>
    </div>

    <div class="section-container" id="section-about">
        <div class="section-content">
            <h2>About</h2>
            <p>Designer and developer focused on crafting interfaces that feel inevitable. Based in the intersection of form and function.</p>
        </div>
    </div>

    <div class="section-container" id="section-skills">
        <div class="section-content">
            <h2>Skills</h2>
            <p>Frontend architecture, motion design, creative coding, and the delicate art of making complex things feel simple.</p>
        </div>
    </div>

    <script>
        // ============================================
        // PARTICLE SYSTEM (Zone Density Concentration)
        // ============================================
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');

        const apertureCanvas = document.getElementById('aperture-canvas');
        const apertureCtx = apertureCanvas.getContext('2d');

        const CONFIG = {
            particleCount: 800,
            particleSize: 1.2,
            baseColor: '39, 39, 42',
            zoneConcentration: 0.6,
            mouseRadius: 100,
            apertureDuration: 0.7
        };

        let particles = [];
        let apertureParticles = [];
        let width, height;
        let mouse = { x: -9999, y: -9999 };
        let hoveredZone = null;
        let activeSection = null;
        let apertureState = 0; // 0 = closed, 1 = fully open
        let apertureCenter = { x: 0, y: 0 };
        let isAnimating = false;

        // Zone centers for particle concentration
        const zonePositions = {
            'projects': { x: 0.25, y: 0.25 },
            'contact': { x: 0.75, y: 0.25 },
            'about': { x: 0.25, y: 0.75 },
            'skills': { x: 0.75, y: 0.75 }
        };

        class Particle {
            constructor(zone = null) {
                this.zone = zone;
                this.reset();
            }

            reset() {
                // Concentrate particles near zone centers
                if (this.zone && Math.random() < CONFIG.zoneConcentration) {
                    const pos = zonePositions[this.zone];
                    const spread = 0.15;
                    this.x = (pos.x + (Math.random() - 0.5) * spread) * width;
                    this.y = (pos.y + (Math.random() - 0.5) * spread) * height;
                } else {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                }

                this.originX = this.x;
                this.originY = this.y;
                this.size = Math.random() * CONFIG.particleSize + 0.5;
                this.alpha = Math.random() * 0.5 + 0.2;
                this.baseAlpha = this.alpha;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderSpeed = 0.1 + Math.random() * 0.15;
            }

            update() {
                this.wanderAngle += (Math.random() - 0.5) * 0.08;
                this.x += Math.cos(this.wanderAngle) * this.wanderSpeed;
                this.y += Math.sin(this.wanderAngle) * this.wanderSpeed;

                // Mouse repulsion
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < CONFIG.mouseRadius) {
                    const force = (CONFIG.mouseRadius - dist) / CONFIG.mouseRadius;
                    this.x -= (dx / dist) * force * 2;
                    this.y -= (dy / dist) * force * 2;
                }

                // Hover attraction to zone
                if (hoveredZone && this.zone === hoveredZone) {
                    const pos = zonePositions[hoveredZone];
                    const targetX = pos.x * width;
                    const targetY = pos.y * height;
                    this.x += (targetX - this.x) * 0.01;
                    this.y += (targetY - this.y) * 0.01;
                    this.alpha = Math.min(this.baseAlpha * 1.5, 1);
                } else {
                    this.alpha = this.baseAlpha;
                }

                // Soft wrap
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }

            draw() {
                particleCtx.fillStyle = `rgba(${CONFIG.baseColor}, ${this.alpha})`;
                particleCtx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Aperture edge particles
        class ApertureParticle {
            constructor(angle, radius) {
                this.baseAngle = angle;
                this.baseRadius = radius;
                this.angle = angle;
                this.radius = radius;
                this.size = Math.random() * 2 + 1;
                this.alpha = Math.random() * 0.8 + 0.2;
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.02 + Math.random() * 0.03;
                this.wobbleAmount = 5 + Math.random() * 10;
            }

            update(centerX, centerY, currentRadius) {
                this.wobble += this.wobbleSpeed;
                const wobbleOffset = Math.sin(this.wobble) * this.wobbleAmount;

                this.radius = currentRadius + wobbleOffset;
                this.x = centerX + Math.cos(this.angle) * this.radius;
                this.y = centerY + Math.sin(this.angle) * this.radius;

                // Slight angle drift
                this.angle = this.baseAngle + Math.sin(this.wobble * 0.5) * 0.05;
            }

            draw() {
                apertureCtx.fillStyle = `rgba(${CONFIG.baseColor}, ${this.alpha})`;
                apertureCtx.beginPath();
                apertureCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                apertureCtx.fill();
            }
        }

        function initParticles() {
            width = particleCanvas.width = apertureCanvas.width = window.innerWidth;
            height = particleCanvas.height = apertureCanvas.height = window.innerHeight;
            particles = [];

            const zones = Object.keys(zonePositions);
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const zone = zones[i % zones.length];
                particles.push(new Particle(zone));
            }

            initApertureParticles();
        }

        function initApertureParticles() {
            apertureParticles = [];
            const maxRadius = Math.max(width, height);
            const particleCount = 400;

            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                apertureParticles.push(new ApertureParticle(angle, maxRadius * 0.6));
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Clear canvases
            particleCtx.clearRect(0, 0, width, height);
            apertureCtx.clearRect(0, 0, width, height);

            // Draw background particles (only when aperture not fully open)
            if (apertureState < 1) {
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });
            }

            // Draw aperture mask
            if (apertureState > 0 && apertureState < 1) {
                drawApertureMask();
            }
        }

        function drawApertureMask() {
            const maxRadius = Math.max(width, height) * 1.5;
            const currentRadius = maxRadius * apertureState;

            // Draw the mask (everything outside the aperture)
            apertureCtx.save();
            apertureCtx.fillStyle = '#fafafa';

            // Create circular reveal by filling around it
            apertureCtx.beginPath();
            apertureCtx.rect(0, 0, width, height);
            apertureCtx.arc(apertureCenter.x, apertureCenter.y, currentRadius, 0, Math.PI * 2, true);
            apertureCtx.fill();

            // Draw particle edge
            apertureParticles.forEach(p => {
                p.update(apertureCenter.x, apertureCenter.y, currentRadius);
                p.draw();
            });

            apertureCtx.restore();
        }

        // ============================================
        // APERTURE NAVIGATION
        // ============================================
        const zones = document.querySelectorAll('.zone');
        const closeBtn = document.getElementById('close-btn');
        const centerHint = document.getElementById('center-hint');

        function getZoneCenter(zoneName) {
            const pos = zonePositions[zoneName];
            return {
                x: pos.x * width,
                y: pos.y * height
            };
        }

        function showPreview(sectionName) {
            if (activeSection || isAnimating) return;

            const section = document.getElementById(`section-${sectionName}`);
            if (!section) return;

            // Show dimmed preview
            section.classList.add('preview');

            // Set aperture center
            const center = getZoneCenter(sectionName);
            apertureCenter.x = center.x;
            apertureCenter.y = center.y;

            // Crack open aperture slightly
            gsap.to({ value: apertureState }, {
                value: 0.15,
                duration: 0.4,
                ease: 'power2.out',
                onUpdate: function() {
                    apertureState = this.targets()[0].value;
                }
            });
        }

        function hidePreview(sectionName) {
            if (activeSection || isAnimating) return;

            const section = document.getElementById(`section-${sectionName}`);
            if (section) {
                section.classList.remove('preview');
            }

            // Close aperture
            gsap.to({ value: apertureState }, {
                value: 0,
                duration: 0.3,
                ease: 'power2.in',
                onUpdate: function() {
                    apertureState = this.targets()[0].value;
                }
            });
        }

        function openSection(sectionName) {
            if (activeSection || isAnimating) return;
            isAnimating = true;

            const section = document.getElementById(`section-${sectionName}`);
            if (!section) return;

            section.classList.remove('preview');
            section.classList.add('active');

            // Hide zones and hint
            zones.forEach(z => z.style.pointerEvents = 'none');
            centerHint.classList.add('hidden');

            // Set aperture center
            const center = getZoneCenter(sectionName);
            apertureCenter.x = center.x;
            apertureCenter.y = center.y;

            // Animate aperture open
            gsap.to({ value: apertureState }, {
                value: 1,
                duration: CONFIG.apertureDuration,
                ease: 'power2.inOut',
                onUpdate: function() {
                    apertureState = this.targets()[0].value;
                },
                onComplete: () => {
                    isAnimating = false;
                    activeSection = sectionName;
                }
            });

            // Show close button
            gsap.to(closeBtn, {
                opacity: 1,
                duration: 0.3,
                delay: CONFIG.apertureDuration * 0.5,
                onStart: () => closeBtn.classList.add('visible')
            });

            // Animate content
            const content = section.querySelector('.section-content');
            const h2 = content.querySelector('h2');
            const p = content.querySelector('p');

            gsap.fromTo([h2, p],
                { opacity: 0, y: 30 },
                {
                    opacity: 1,
                    y: 0,
                    duration: 0.6,
                    stagger: 0.15,
                    delay: CONFIG.apertureDuration * 0.6,
                    ease: 'power3.out'
                }
            );
        }

        function closeSection() {
            if (!activeSection || isAnimating) return;
            isAnimating = true;

            const section = document.getElementById(`section-${activeSection}`);

            // Fade out content first
            const content = section.querySelector('.section-content');
            const h2 = content.querySelector('h2');
            const p = content.querySelector('p');

            gsap.to([p, h2], {
                opacity: 0,
                y: -20,
                duration: 0.3,
                stagger: 0.1,
                ease: 'power2.in'
            });

            // Hide close button
            gsap.to(closeBtn, {
                opacity: 0,
                duration: 0.2,
                onComplete: () => closeBtn.classList.remove('visible')
            });

            // Close aperture
            gsap.to({ value: apertureState }, {
                value: 0,
                duration: CONFIG.apertureDuration,
                delay: 0.2,
                ease: 'power2.inOut',
                onUpdate: function() {
                    apertureState = this.targets()[0].value;
                },
                onComplete: () => {
                    section.classList.remove('active');
                    zones.forEach(z => z.style.pointerEvents = 'auto');
                    centerHint.classList.remove('hidden');
                    isAnimating = false;
                    activeSection = null;
                }
            });
        }

        // Event Listeners
        zones.forEach(zone => {
            const sectionName = zone.dataset.section;

            zone.addEventListener('mouseenter', () => {
                hoveredZone = sectionName;
                showPreview(sectionName);
            });

            zone.addEventListener('mouseleave', () => {
                hoveredZone = null;
                hidePreview(sectionName);
            });

            zone.addEventListener('click', () => {
                openSection(sectionName);
            });

            // Touch support
            zone.addEventListener('touchstart', () => {
                hoveredZone = sectionName;
                showPreview(sectionName);
            });

            zone.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (hoveredZone === sectionName) {
                    openSection(sectionName);
                }
            });
        });

        closeBtn.addEventListener('click', closeSection);
        closeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            closeSection();
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && activeSection) {
                closeSection();
            }
        });

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }
        });

        // Initialize
        window.addEventListener('resize', initParticles);
        initParticles();
        animate();
    </script>
</body>
</html>
